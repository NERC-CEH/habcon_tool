#' DISCLAIMER: This documentation was generated by ChatGPT.
#' Please review and edit as needed to ensure accuracy and completeness.

#' Combine Polygons That Touch or Are Close
#'
#' Combines polygons in a spatial object that either touch or are within a specified distance of each other.
#'
#' @param comb_obj `sf` object containing the polygons to combine.
#' @param variable_name `character` Name of the column used for grouping polygons. If `NULL`, polygons are combined without grouping. Defaults to `NULL`.
#' @param combine_close `logical` Whether to combine polygons that are within `connect_dist` of each other. Defaults to `TRUE`.
#' @param connect_dist `numeric` Distance threshold for combining polygons (in spatial units). Defaults to `100`.
#' @param Plot `logical` Whether to plot the combined polygons. Defaults to `TRUE`.
#'
#' @return An `sf` object with combined polygons and updated grouping information.
#' @importFrom sf st_union st_intersects st_cast
#' @importFrom ggplot2 ggplot geom_sf theme_bw ggtitle theme
#' @examples
#' \dontrun{
#' combined <- combine_touching(spatial_data, "habitat_type", TRUE, 200, TRUE)
#' }
#' @export
combine_touching <- function(comb_obj, variable_name, combine_close, 
                             connect_dist = 100, Plot = TRUE) {
  
  if(class(comb_obj)[1] != "sf") stop("'comb_object' must be of class 'sf'")
  if(!is.null(variable_name) & !variable_name %in% colnames(comb_obj)) stop("'variable_name' must be a column name (as character) found in 'comb_obj' or NULL")
  
  # combine overlapping polygons by casting all multipolygons to polygons
  # check for intersections between that and original object
  # unlist the IDs to use as a grouping column
  parts <- st_cast(st_union(comb_obj),"POLYGON")
  int <- st_intersects(comb_obj, parts)
  clust <- unlist(lapply(1:length(int), function(x) paste(int[[x]], collapse = '_')))
  
  # group by the column and join the overlapping objects together
  if(!is.null(variable_name)) {
    
    comb_obj$variable <- data.frame(comb_obj)[,variable_name]
    
    diss <- cbind(comb_obj, clust) %>%
      group_by(clust) %>%
      summarise(variable = paste(unique(variable), collapse = ', ')) %>% 
      rename('poly_id' = 'clust')
    
  } else if(is.null(variable_name)) {
    
    diss <- cbind(comb_obj, clust) %>%
      group_by(clust) %>%
      summarise() %>% 
      rename('poly_id' = 'clust')
    
  }
  
  
  # Combine polygons that are close to consider them as a single polygon
  # habitats within connect_dist are already considered as one because species
  # can already use them
  if(combine_close){
    
    # use my own function to determine which objects are within connection_distance of
    # each other - produces an id of all objects within that distance.
    # Works with finding patches that are linked to other ones via intermediate habitats
    int_within_dist_id <- is_within_dist(sf_obj = diss, connect_dist = connect_dist)
    
    # use the ID to combine the polygons
    if(!is.null(variable_name)) {
      
      diss <- cbind(diss, int_within_dist_id) %>%
        group_by(int_within_dist_id) %>%
        summarise(variable = paste(unique(variable), collapse = ', ')) %>% 
        rename('poly_id' = 'int_within_dist_id')
      
    } else if(is.null(variable_name)) {
      
      diss <- cbind(diss, int_within_dist_id) %>%
        group_by(int_within_dist_id) %>%
        summarise() %>% 
        rename('poly_id' = 'int_within_dist_id')
      
    }
    
  }
  
  if(Plot){
    
    p <- diss %>% 
      ggplot() +
      geom_sf(aes(fill = poly_id)) +
      theme_bw() +
      ggtitle('Combined polygons') +
      theme(legend.position = 'none')
    print(p)
    
  }
  
  return(diss)
  
}


#' Filter Polygons by Minimum Area
#'
#' Filters polygons in a spatial object to retain only those with an area above a specified threshold.
#'
#' @param spatial_object `SpatRaster` or `sf` object containing polygons to filter.
#' @param min_area `numeric` Minimum area (in square meters) to retain a polygon. 
#'
#' @return An `sf` object containing polygons that meet the area requirement.
#' @importFrom sf st_area st_cast st_as_sf
#' @examples
#' \dontrun{
#' large_polygons <- filter_min_area(spatial_data, 500)
#' }
#' @export
filter_min_area <- function(spatial_object, min_area) {
  
  # To get minimum area, need to convert everything to an sf_object
  # as don't know how to measure area in raster of each overlap separately
  connect_vect <- as.polygons(spatial_object)
  
  # st_cast() doesn't work properly if sf object contains polygons and 
  # multipolygons - convert to multipolygon first before converting to poly
  homog_poly <- st_cast(st_as_sf(connect_vect), 'MULTIPOLYGON')
  connect_poly <- st_cast(homog_poly, 'POLYGON')
  connect_poly$area <- st_area(connect_poly)
  
  lrge_connects <- connect_poly[connect_poly$area>units::set_units(min_area, 'm^2'),]
  
  return(lrge_connects)
  
}


#' Get Extremes of a Polygon's Coordinates
#'
#' Identifies the outermost coordinates (min/max x and y) of a polygon.
#'
#' @param sf_poly `sf` object representing the polygon.
#'
#' @return A `data.frame` with columns `x_min`, `x_max`, `y_min`, and `y_max`.
#' @importFrom sf st_coordinates st_cast
#' @examples
#' \dontrun{
#' extremes <- get_poly_extremes(polygon_data)
#' }
#' @export
get_poly_extremes <- function(sf_poly) {
  coord_box <- data.frame(st_coordinates(st_cast(st_cast(sf_poly, 'MULTIPOLYGON'), 'POLYGON')))
  
  data.frame(x_min = min(coord_box$X), 
             x_max = max(coord_box$X), 
             y_min = min(coord_box$Y), 
             y_max = max(coord_box$Y))
}



#' Identify Objects Within a Distance
#'
#' Determines which objects in an `sf` object are within a specified distance of each other.
#'
#' @param sf_obj `sf` object containing the spatial data.
#' @param connect_dist `numeric` Distance threshold (in spatial units) to identify connections.
#'
#' @return A character vector where each element is an identifier for groups of objects within the specified distance.
#' @importFrom sf st_is_within_distance
#' @examples
#' \dontrun{
#' within_dist_ids <- is_within_dist(spatial_data, 200)
#' }
#' @export
is_within_dist <- function(sf_obj, connect_dist){
  
  # identify patches within distance
  win_dist <- st_is_within_distance(sf_obj, dist = connect_dist, remove_self = FALSE)
  
  # Find objects that have matching numbers
  # to use as a grouping variable. Loop through each ID in turn and look
  # for all matching values in other IDs
  for(i in 1:length(win_dist)) { 
    for(j in 1:length(win_dist)) {
      if(any(win_dist[[i]] %in% win_dist[[j]])) {
        
        id_vals <- sort(unique(c(win_dist[[i]], win_dist[[j]])))
        
        win_dist[[i]] <- id_vals
        win_dist[[j]] <- id_vals
        
      }
    }
  }
  
  # condense id into single, sorted, id col
  within_dist_id <- sapply(win_dist, FUN = function(i) paste(sort(i), collapse = '_'))
  return(within_dist_id)
}


#' Convert Polygons to Raster
#'
#' Converts polygons into a raster format with specified resolution and optional extent.
#'
#' @param obj `sf` object containing polygons to convert.
#' @param field_val `numeric` or `character` Field value(s) to assign to the raster cells.
#' @param resolution `numeric` Vector of two values specifying raster resolution (e.g., `c(10, 10)`).
#' @param rast_extent `SpatExtent` Optional extent for the raster. Defaults to `NULL`.
#' @param layer_names `character` Optional names for the raster layers.
#'
#' @return A `SpatRaster` object.
#' @importFrom terra rast vect ext rasterize
#' @examples
#' \dontrun{
#' raster <- poly_to_rast(polygon_data, field_val = 1, resolution = c(10, 10))
#' }
#' @export
poly_to_rast <- function(obj, field_val = 1, resolution = c(10,10), rast_extent = NULL, layer_names = NULL) {
  
  print('!! converting polygon to raster')
  
  # convert raster to spatial format
  buffered_object_points <- vect(obj)
  
  # from this, create a template raster to fill
  # if extent not provided then create own based on the buffered object
  if(is.null(rast_extent)) {
    template_rast <- terra::rast(crs = as.character(crs(buffered_object_points)), 
                                 extent = terra::ext(buffered_object_points),
                                 vals = 0, resolution = resolution)
  } else {
    template_rast <- terra::rast(crs = as.character(crs(buffered_object_points)),
                                 extent = terra::ext(rast_extent),
                                 vals = 0, resolution = resolution)
  }
  
  # fill the template with the points above, giving the values in the 'n_overlaps' column
  
  if(length(field_val) == 1) {
    buffered_object_rast <- terra::rast(
      lapply(1:nrow(buffered_object_points), 
             FUN = function(x) terra::rasterize(buffered_object_points[x,], 
                                                template_rast, field = field_val))
    )
  } else if(length(field_val)>1) {
    buffered_object_rast <- terra::rast(
      lapply(1:nrow(buffered_object_points), 
             FUN = function(x) terra::rasterize(buffered_object_points[x,], 
                                                template_rast, field = field_val[x]))
    )
  }
  
  
  
  if(!is.null(layer_names)) names(buffered_object_rast) <- layer_names
  
  return(buffered_object_rast)
  
}


